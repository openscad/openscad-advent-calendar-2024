/*
 * Welcome to the Advent Calendar - Tutorial Edition - Part 09
 */


step = 1; // [1:3]

/*** STEP 1 ***/

// Modules define geometry that can be called (instantiated) multiple
// times, similar to how functions do that for expressions.

// We define a module named "hollow_cube" that is generated by subtracting
// a sphere from a cube. Just adding the module definition does not
// produce any output, for that we also add two module instantiations
// of hollow_cube() translated to different places.

module hollow_cube() {
	difference() {
		cube(40, center = true);
		sphere(25);
	}
}

if (step == 1) {

translate([-40, 0, 0]) hollow_cube();
translate([40, 0, 0]) hollow_cube();

}

/*** STEP 2 ***/

// Modules can declare parameters. Parameters can have default values
// which are used in case the parameter is not given in the instantiation.

// Parameters are assigned from left to right, but if multiple parameters
// of a module have default values, it's possible to give specific values
// by name while keeping the other defaults.

function n_gon(n, r) = [for (a = [0:n-1]) r * [cos(a * 360 / n), sin(a * 360 / n)]];

module n_gon_bowl(n, r, height = 10, wall = 1) {
	difference() {
		linear_extrude(height)
			polygon(n_gon(n, r));
		translate([0, 0, wall])
			linear_extrude(height)
				polygon(n_gon(n, r - wall));
	}
}

if (step == 2) {

// specifying all parameters
translate([-40, 0, 0]) n_gon_bowl(5, 30, 15, 2);

// specifying one optional parameter by name
translate([30, 30, 0]) n_gon_bowl(8, 20, wall = 3);

// specifying only the mandatory parameters
translate([30, -40, 0]) n_gon_bowl(6, 25);

}

/*** STEP 3 ***/

// By giving different values for the parameters, a single module can
// produce a wide range of models.
// Deciding which parameters are best can be difficult. It often is
// helpful defining the parameters not just based on all the technical or
// mathematical properties, but more thinking on how to easily specify
// different use cases. For example when writing a module for creating
// pockets to hold metric nuts, it's much easier to use if the input
// parameter specifies the nut size like "M3" and leave the calculation
// of the dimensions to the module rather than forcing the user to find
// all the technical values and pass them to the module.

// In part 7, we created candles, so lets create a candle holder.
// We only want the module to get the number and the diameter of the
// candles. The module should then create a candle holder based on
// that. We add an optional h parameter that can modify the height of
// the holder if the default is not working for some candles.

module candle_holder(n, d, h = 10) {
	wall = 2; // fixed wall thickness

	// we want the candle holder to be very different based on the
	// number of candles. We can use if / else to create different
	// geometry based on some value
	if (n == 1) {
		// single candle, just a simple hexagon block
		difference() {
			linear_extrude(h)
				polygon(n_gon(6, d / 2 + wall));
			translate([0, 0, wall]) cylinder(d = d, h = h);
		}
	} else if (n == 2) {
		// Two candles, a long block with places for the candles
		// on both ends. The size of the block is defined based
		// on the candle diameter.
		difference() {
			union() {
				linear_extrude(wall)
					square([5 * d + 4 * wall, d + 4 * wall], center = true);
				translate([-2 * d, 0, 0]) cylinder(d = d + 2 * wall, h = h);
				translate([2 * d, 0, 0]) cylinder(d = d + 2 * wall, h = h);
			}
			translate([-2 * d, 0, wall]) cylinder(d = d, h = h);
			translate([2 * d, 0, wall]) cylinder(d = d, h = h);
		}
	} else {
		// Three or more candles, create a round base and place
		// the candles on top of that.	Using for() we can
		// create geometry in a loop based on a value instead
		// of directly specifying each single instance
		difference() {
			union() {
				linear_extrude(wall) difference() {
					circle(5 * d);
					circle(3 * d);
				}
				for (a = [0:n-1])
					rotate(a * 360 / n)
						translate([4 * d, 0, 0])
							cylinder(d = d + 2 * wall, h = h);
			}
			for (a = [0:n-1])
				rotate(a * 360 / n)
					translate([4 * d, 0, wall])
						cylinder(d = d, h = h);
		}
	}
}

if (step == 3) {

translate([0,  70, 0]) candle_holder(1, 8);
translate([0,  30, 0]) candle_holder(2, 8);
translate([0, -40, 0]) candle_holder(3, 8);

}

/*** THE END ***/

/*********************************************************************/

// Written in 2024 by Torsten Paul <Torsten.Paul@gmx.de>
//
// To the extent possible under law, the author(s) have dedicated all
// copyright and related and neighboring rights to this software to the
// public domain worldwide. This software is distributed without any
// warranty.
//
// You should have received a copy of the CC0 Public Domain
// Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.

$fa = 1; $fs = 0.2;
